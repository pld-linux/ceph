--- ceph-16.2.7/src/SimpleRADOSStriper.cc~	2021-12-07 17:15:49.000000000 +0100
+++ ceph-16.2.7/src/SimpleRADOSStriper.cc	2022-02-12 21:59:28.261721940 +0100
@@ -140,7 +140,7 @@
   return 0;
 }
 
-int SimpleRADOSStriper::truncate(uint64_t size)
+int SimpleRADOSStriper::truncate(size_t size)
 {
   d(5) << size << dendl;
 
--- ceph-17.2.7/src/os/bluestore/BlueFS.cc.orig	2024-02-24 21:45:42.755706899 +0100
+++ ceph-17.2.7/src/os/bluestore/BlueFS.cc	2024-02-24 21:51:20.641018002 +0100
@@ -4617,7 +4617,7 @@ size_t BlueFS::probe_alloc_avail(int dev
     if (dist_to_alignment >= len)
       return;
     len -= dist_to_alignment;
-    total += p2align(len, alloc_size);
+    total += p2align((uint64_t)len, alloc_size);
   };
   if (alloc[dev]) {
     alloc[dev]->foreach(iterated_allocation);
--- ceph-16.2.7/src/tools/neorados.cc~	2021-12-07 17:15:49.000000000 +0100
+++ ceph-16.2.7/src/tools/neorados.cc	2022-02-12 22:23:25.836643956 +0100
@@ -205,7 +205,7 @@
 
   std::size_t off = 0;
   ceph::buffer::list bl;
-  while (auto toread = std::max(len - off, io_size)) {
+  while (auto toread = std::max(len - off, (uint64_t)io_size)) {
     R::ReadOp op;
     op.read(off, toread, &bl);
     r.execute(obj, pool, std::move(op), nullptr, y[ec]);
--- ceph-16.2.7/src/tools/cephfs_mirror/FSMirror.cc.orig	2021-12-07 17:15:49.000000000 +0100
+++ ceph-16.2.7/src/tools/cephfs_mirror/FSMirror.cc	2022-02-12 22:30:46.487298972 +0100
@@ -345,7 +345,7 @@
     std::scoped_lock locker(m_lock);
     m_directories.emplace(dir_path);
     m_service_daemon->add_or_update_fs_attribute(m_filesystem.fscid, SERVICE_DAEMON_DIR_COUNT_KEY,
-                                                 m_directories.size());
+                                                 (uint64_t)m_directories.size());
 
     for (auto &[peer, peer_replayer] : m_peer_replayers) {
       dout(10) << ": peer=" << peer << dendl;
@@ -363,7 +363,7 @@
     if (it != m_directories.end()) {
       m_directories.erase(it);
       m_service_daemon->add_or_update_fs_attribute(m_filesystem.fscid, SERVICE_DAEMON_DIR_COUNT_KEY,
-                                                   m_directories.size());
+                                                   (uint64_t)m_directories.size());
       for (auto &[peer, peer_replayer] : m_peer_replayers) {
         dout(10) << ": peer=" << peer << dendl;
         peer_replayer->remove_directory(dir_path);
--- ceph-17.2.3/src/seastar/src/core/file.cc.orig	2021-12-19 23:02:10.000000000 +0100
+++ ceph-17.2.3/src/seastar/src/core/file.cc	2022-08-28 09:19:17.258501014 +0200
@@ -313,7 +313,7 @@ posix_file_impl::close() noexcept {
 
 future<uint64_t>
 blockdev_file_impl::size(void) noexcept {
-    return engine()._thread_pool->submit<syscall_result_extra<size_t>>([this] {
+    return engine()._thread_pool->submit<syscall_result_extra<uint64_t>>([this] {
         uint64_t size;
         int ret = ::ioctl(_fd, BLKGETSIZE64, &size);
         return wrap_syscall(ret, size);
@@ -908,7 +908,7 @@ append_challenged_posix_file_impl::trunc
 
 future<uint64_t>
 append_challenged_posix_file_impl::size() noexcept {
-    return make_ready_future<size_t>(_logical_size);
+    return make_ready_future<uint64_t>(_logical_size);
 }
 
 future<>
--- ceph-17.2.3/src/seastar/src/core/fstream.cc.orig	2021-12-19 23:02:10.000000000 +0100
+++ ceph-17.2.3/src/seastar/src/core/fstream.cc	2022-08-28 09:22:32.072057177 +0200
@@ -419,7 +419,7 @@ private:
         if ((buf.size() & (_file.disk_write_dma_alignment() - 1)) != 0) {
             // If buf size isn't aligned, copy its content into a new aligned buf.
             // This should only happen when the user calls output_stream::flush().
-            auto tmp = allocate_buffer(align_up(buf.size(), _file.disk_write_dma_alignment()));
+            auto tmp = allocate_buffer(align_up<uint64_t>(buf.size(), _file.disk_write_dma_alignment()));
             ::memcpy(tmp.get_write(), buf.get(), buf.size());
             ::memset(tmp.get_write() + buf.size(), 0, tmp.size() - buf.size());
             buf = std::move(tmp);
